# strategies/base_strategy.py
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime
import numpy as np

from container import container
from log_service.logger import LoggingService
from database.models import PriceBar
from database.repository import PriceRepository
from strategies.indicator_utils import IndicatorUtils
from strategies.config import StrategyConfig, TimeFrameType, RiskManagementConfig


class Signal:
    """Represents a trading signal generated by a strategy"""

    def __init__(self,
                 symbol: str,
                 direction: str,  # "BUY" or "SELL"
                 entry_price: float,
                 stop_loss: float,
                 take_profit: float,
                 strategy_name: str,
                 timeframe: str,
                 timestamp: datetime,
                 volume: float = None,
                 custom_data: Dict[str, Any] = None):
        self.symbol = symbol
        self.direction = direction
        self.entry_price = entry_price
        self.stop_loss = stop_loss
        self.take_profit = take_profit
        self.strategy_name = strategy_name
        self.timeframe = timeframe
        self.timestamp = timestamp
        self.volume = volume
        self.custom_data = custom_data or {}

    def risk_reward_ratio(self) -> float:
        """Calculate the risk-reward ratio for this signal"""
        risk = abs(self.entry_price - self.stop_loss)
        if risk == 0:
            return 0.0

        reward = abs(self.take_profit - self.entry_price)
        return reward / risk

    def __str__(self) -> str:
        return (f"{self.strategy_name} {self.direction} Signal for {self.symbol} at {self.entry_price}, "
                f"SL: {self.stop_loss}, TP: {self.take_profit}, R:R = {self.risk_reward_ratio():.2f}")


class BaseStrategy(ABC):
    """Base class for all trading strategies"""

    def __init__(self, config: StrategyConfig, symbol: str, timeframe: TimeFrameType):
        """
        Initialize the strategy.

        Args:
            config: Strategy configuration
            symbol: Trading instrument symbol
            timeframe: Trading timeframe
        """
        self.config = config
        self.symbol = symbol
        self.timeframe = timeframe
        self.name = config.name
        self._logging_service = container.resolve(LoggingService)
        self._price_repository = container.resolve(PriceRepository)
        self._indicators = IndicatorUtils()

        self.log('INFO', f"Initialized {self.name} for {symbol} on {timeframe.value}")

    def log(self, level: str, message: str) -> None:
        """
        Log a message with the strategy context.

        Args:
            level: Log level ('INFO', 'WARNING', 'ERROR', 'CRITICAL')
            message: Message to log
        """
        component = f"strategy.{self.name.lower().replace(' ', '_')}"
        self._logging_service.log(level, component, f"[{self.symbol}][{self.timeframe.value}] {message}")

    def get_price_bars(self, count: int = 300) -> List[PriceBar]:
        """
        Get the most recent price bars for this strategy's symbol and timeframe.

        Args:
            count: Number of bars to retrieve

        Returns:
            List of price bars or empty list if none available
        """
        try:
            return self._price_repository.get_price_bars(self.symbol, self.timeframe.value, count)
        except Exception as e:
            self.log('ERROR', f"Failed to get price bars: {str(e)}")
            return []

    def extract_ohlcv(self, bars: List[PriceBar]) -> Dict[str, np.ndarray]:
        """
        Extract OHLCV data from price bars for indicator calculations.

        Args:
            bars: List of price bars

        Returns:
            Dictionary with numpy arrays for open, high, low, close, volume, timestamps
        """
        if not bars:
            return {
                'open': np.array([]),
                'high': np.array([]),
                'low': np.array([]),
                'close': np.array([]),
                'volume': np.array([]),
                'timestamp': np.array([])
            }

        timestamps = np.array([bar.timestamp for bar in bars])
        opens = np.array([bar.open for bar in bars])
        highs = np.array([bar.high for bar in bars])
        lows = np.array([bar.low for bar in bars])
        closes = np.array([bar.close for bar in bars])
        volumes = np.array([bar.volume for bar in bars])

        return {
            'open': opens,
            'high': highs,
            'low': lows,
            'close': closes,
            'volume': volumes,
            'timestamp': timestamps
        }

    def calculate_position_size(self, risk_config: RiskManagementConfig, entry_price: float,
                                stop_loss: float, account_balance: float) -> float:
        """
        Calculate position size based on risk parameters.

        Args:
            risk_config: Risk management configuration
            entry_price: Entry price
            stop_loss: Stop loss price
            account_balance: Current account balance

        Returns:
            Position size (in lots)
        """
        risk_amount = account_balance * (risk_config.max_risk_per_trade_percent / 100.0)
        risk_per_pip = abs(entry_price - stop_loss)

        if risk_per_pip <= 0:
            self.log('WARNING', f"Invalid risk calculation: entry={entry_price}, stop={stop_loss}")
            return 0.0

        # Calculate position size in lots
        # This is a simplified calculation, would need to be adjusted for specific instruments
        position_size = risk_amount / risk_per_pip

        # Ensure position size doesn't exceed max allowed
        max_position_size = account_balance * (risk_config.max_position_size_percent / 100.0)
        if position_size > max_position_size:
            position_size = max_position_size

        return position_size

    def calculate_stop_loss(self, direction: str, entry_price: float, atr_value: float) -> float:
        """
        Calculate stop loss price based on ATR.

        Args:
            direction: Trade direction ('BUY' or 'SELL')
            entry_price: Entry price
            atr_value: Current ATR value

        Returns:
            Stop loss price
        """
        atr_multiplier = self.config.risk_management.stop_loss_atr_multiplier

        if direction == 'BUY':
            return entry_price - (atr_value * atr_multiplier)
        else:
            return entry_price + (atr_value * atr_multiplier)

    def calculate_take_profit(self, direction: str, entry_price: float, atr_value: float) -> float:
        """
        Calculate take profit price based on ATR.

        Args:
            direction: Trade direction ('BUY' or 'SELL')
            entry_price: Entry price
            atr_value: Current ATR value

        Returns:
            Take profit price
        """
        atr_multiplier = self.config.risk_management.take_profit_atr_multiplier

        if direction == 'BUY':
            return entry_price + (atr_value * atr_multiplier)
        else:
            return entry_price - (atr_value * atr_multiplier)

    @abstractmethod
    def evaluate(self, new_bar: PriceBar) -> Optional[Signal]:
        """
        Evaluate the strategy for a new price bar.

        Args:
            new_bar: The newly arrived price bar

        Returns:
            A Signal object if a trade signal is generated, None otherwise
        """
        pass

    def is_valid_session(self, timestamp: datetime, session_name: str) -> bool:
        """
        Check if the current time is within a specified trading session.

        Args:
            timestamp: The current timestamp
            session_name: Name of the session to check

        Returns:
            True if within the specified session, False otherwise
        """
        return self._indicators.is_valid_session(timestamp, session_name)

    # In strategies/base_strategy.py
    # Update the log_conditions method

    def log_conditions(self, signal_type: str, condition_groups: Dict[str, List[Tuple[str, bool, str]]]) -> bool:
        """
        Log all conditions being checked for a signal type with enhanced formatting.

        Args:
            signal_type: Type of signal (e.g., "BUY", "SELL", "EXIT")
            condition_groups: Dictionary of condition groups, each containing tuples of
                             (condition_name, condition_met, details)

        Returns:
            bool: True if all conditions in all groups are met, False otherwise
        """
        # ANSI color codes
        GREEN = '\033[92m'
        RED = '\033[91m'
        YELLOW = '\033[93m'
        BLUE = '\033[94m'
        MAGENTA = '\033[95m'
        CYAN = '\033[96m'
        BOLD = '\033[1m'
        UNDERLINE = '\033[4m'
        RESET = '\033[0m'

        # Check mark and X symbols with colors
        CHECK = f"{GREEN}✓{RESET}"
        CROSS = f"{RED}✗{RESET}"

        # Track if all conditions are met
        all_conditions_met = True

        # Log minimal info to log file
        self.log('INFO', f"Evaluating {signal_type} conditions")

        # Log header with distinctive formatting
        header = (
            f"\n{BOLD}{BLUE}{'=' * 80}{RESET}\n"
            f"{BOLD}{MAGENTA}STRATEGY:{RESET} {BOLD}{self.name}{RESET} | "
            f"{BOLD}{YELLOW}PAIR:{RESET} {BOLD}{self.symbol}{RESET} | "
            f"{BOLD}{CYAN}TIMEFRAME:{RESET} {BOLD}{self.timeframe.value}{RESET} | "
            f"{BOLD}{signal_type}{RESET}\n"
            f"{BOLD}{BLUE}{'-' * 80}{RESET}"
        )

        # Print to console for immediate visibility
        print(header)

        # Process each condition group
        for group_name, conditions in condition_groups.items():
            group_met = all(cond[1] for cond in conditions)
            all_conditions_met = all_conditions_met and group_met

            # Format the group header
            group_status = CHECK if group_met else CROSS
            group_header = f"{BOLD}{group_name}:{RESET} {group_status}"

            # Print to console
            print(group_header)

            # Process each condition in the group
            for cond_name, cond_met, details in conditions:
                # Format the condition line
                status = CHECK if cond_met else CROSS
                cond_line = f"  {status} {cond_name}: {details}"

                # Print to console
                print(cond_line)

        # Print overall result
        result = f"\n{BOLD}RESULT:{RESET} "
        if all_conditions_met:
            result += f"{GREEN}All conditions MET - Signal GENERATED{RESET}"
        else:
            result += f"{RED}Some conditions FAILED - NO Signal{RESET}"

        # Print to console
        print(result)
        print(f"{BLUE}{'=' * 80}{RESET}\n")

        # Log the final result to log file
        if all_conditions_met:
            self.log('INFO', f"All conditions met for {signal_type} - Signal generated")
        else:
            self.log('INFO', f"Some conditions failed for {signal_type} - No signal generated")

        return all_conditions_met
